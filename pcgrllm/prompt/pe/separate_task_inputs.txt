### Reward Function Inputs
def compute_reward(prev_array, prev_stats, curr_array, curr_stats) -> float:
    reward = 0.0

prev_array: jnp.array : previous game level represented with tile numbers
prev_stats: dict : statistics of the previous game level
curr_array: jnp.array : current game level represented with tile numbers
curr_stats: dict : statistics of the current game level

1. 'prev_array' and 'curr_array' (jnp.array, int32)
The array is a 2D array with the shape of (height, width) to represent the game level.
The level is represented with tile numbers. The tile number is an integer value.

Array shape: {array_shape}
Tile Number: {tile_enum}

- Generate reward function which fills "1 (Empty)" to show alphabet shape in the level.
- Make sure "0 (Unavailable)" is not present in the level array. Fill the not passible tile with "2 (Wall)" tile number.


2. stats: (dict[int]): ({stats_keys})
The two metrics represent the structure and complexity of each map, so a balanced reward system should be designed based on them.
The N_Regions means a number of connected empty regions.
The diameter means the distance between the starting point and the ending point.

Target diameter: {Target_diameter}
